from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import socketio
import subprocess
import asyncio
import time
import os
import screen_brightness_control as sbc
import alsaaudio

# --------------------------
# Setup: Socket.IO + FastAPI
# --------------------------

sio = socketio.AsyncServer(
    async_mode='asgi',
    cors_allowed_origins=['http://127.0.0.1:8080', 'http://localhost:8080']
)
fastapi_app = FastAPI(
    title="Jetson + Device API",
    root_path="",
    docs_url="/docs",
    openapi_url="/openapi.json"
)

# CORS middleware - only allow local connections
fastapi_app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://127.0.0.1:8080", "http://localhost:8080"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Final ASGI application
app = socketio.ASGIApp(sio, fastapi_app)

# --------------------------
# System Temperature
# --------------------------

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import socketio
import subprocess
import asyncio
import time
import os
import glob
import screen_brightness_control as sbc
import alsaaudio

# --------------------------
# Setup: Socket.IO + FastAPI
# --------------------------

sio = socketio.AsyncServer(
    async_mode='asgi',
    cors_allowed_origins=['http://127.0.0.1:8080', 'http://localhost:8080']
)
fastapi_app = FastAPI(
    title="Jetson + Device API",
    root_path="",
    docs_url="/docs",
    openapi_url="/openapi.json"
)

# CORS middleware - only allow local connections
fastapi_app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://127.0.0.1:8080", "http://localhost:8080"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Final ASGI application
app = socketio.ASGIApp(sio, fastapi_app)

# --------------------------
# Models
# --------------------------

class ToggleRequest(BaseModel):
    state: str

class VoiceChatRequest(BaseModel):
    action: str  # 'start' or 'stop'

class VolumeRequest(BaseModel):
    volume: int

class WifiConnectRequest(BaseModel):
    ssid: str
    password: str | None = None

# --------------------------
# System Temperature
# --------------------------

CPU_ZONE = "/sys/class/thermal/thermal_zone0/temp"
GPU_ZONE = "/sys/class/thermal/thermal_zone1/temp"

def read_temp(path):
    try:
        with open(path, "r") as f:
            return int(f.read().strip()) / 1000.0  # convert to °C
    except Exception as e:
        print(f"Error reading temperature from {path}: {e}")
        return None

@fastapi_app.get("/system/temperature")
async def get_temperature():
    try:
        cpu_temp = read_temp(CPU_ZONE)
        gpu_temp = read_temp(GPU_ZONE)
        
        print(f"CPU: {cpu_temp:.1f}°C | GPU: {gpu_temp:.1f}°C")
        
        return {
            "cpu_temperature": cpu_temp,
            "gpu_temperature": gpu_temp
        }
    except Exception as e:
        print(f"Error reading temperature: {e}")
        return {"error": str(e)}

# --------------------------
# WiFi
# --------------------------
import subprocess
import asyncio
import time
import os
import screen_brightness_control as sbc
import alsaaudio
import socketio

# --------------------------
# Setup: Socket.IO + FastAPI
# --------------------------

sio = socketio.AsyncServer(
    async_mode='asgi',
    cors_allowed_origins=['http://127.0.0.1:8080', 'http://localhost:8080']
)
fastapi_app = FastAPI(
    title="Jetson + Device API",
    root_path="",
    docs_url="/docs",
    openapi_url="/openapi.json"
)

# CORS middleware - only allow local connections
fastapi_app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://127.0.0.1:8080", "http://localhost:8080"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Final ASGI application
app = socketio.ASGIApp(sio, fastapi_app)

# --------------------------
# Models
# --------------------------

class ToggleRequest(BaseModel):
    state: str

class VoiceChatRequest(BaseModel):
    action: str  # 'start' or 'stop'

class VolumeRequest(BaseModel):
    volume: int

# --------------------------
# Audio
# --------------------------

def get_mixer():
    try:
        return alsaaudio.Mixer('PCM', cardindex=0)
    except:
        try:
            return alsaaudio.Mixer('Master', cardindex=0)
        except:
            mixers = alsaaudio.mixers()
            if mixers:
                return alsaaudio.Mixer(mixers[0])
            raise Exception("No audio mixers found")

@fastapi_app.get("/volume")
async def get_volume():
    try:
        mixer = get_mixer()
        try:
            volumes = mixer.getvolume()
        except AttributeError:
            volumes = [mixer.getvol()[0]]
        return {
            "volume": volumes[0],
            "mixer": mixer.mixer(),
            "card": mixer.cardname()
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@fastapi_app.post("/volume")
async def set_volume(request: VolumeRequest):
    try:
        volume = max(0, min(100, request.volume))
        mixer = get_mixer()
        try:
            mixer.setvolume(volume)
        except AttributeError:
            mixer.setvol(volume)
        return {"success": True, "volume": volume}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# --------------------------
# Voice Chat
# --------------------------

# --------------------------
# Brightness
# --------------------------

@fastapi_app.post("/display/brightness/{level}")
def set_brightness(level: int):
    try:
        if not 0 <= level <= 100:
            return {"error": "Brightness must be 0-100"}
        sbc.set_brightness(level)
        return {"status": "success", "brightness": level}
    except Exception as e:
        return {"status": "failed", "error": str(e)}

@fastapi_app.get("/display/brightness")
def get_brightness():
    try:
        current = sbc.get_brightness(display=0)[0]
        return {"brightness": current}
    except Exception as e:
        return {"status": "failed", "error": str(e)}

# --------------------------
# Wi-Fi
# --------------------------

class WifiConnectRequest(BaseModel):
    ssid: str
    password: str | None = None

@fastapi_app.get("/wifi/scan")
def wifi_scan():
    try:
        # Check WiFi status first
        status = wifi_status()
        if status["status"] == "off":
            return {"networks": [], "status": "off"}

        # Get network info including security
        result = subprocess.run(
            ["nmcli", "-t", "-f", "SSID,SECURITY", "dev", "wifi", "list"],
            capture_output=True,
            text=True,
            check=True
        )
        
        networks = []
        current = current_wifi()
        
        for line in result.stdout.strip().split('\n'):
            if line:
                parts = line.split(":")
                if len(parts) >= 2:
                    ssid = parts[0].strip()
                    security = parts[1] if parts[1] else "--"
                    
                    if ssid:  # skip empty SSID rows
                        network = {
                            "ssid": ssid,
                            "security": security
                        }
                        # Mark if this is the current network
                        if current.get("connected") and current.get("ssid") == ssid:
                            network["connected"] = True
                        networks.append(network)
                        
        return {"networks": networks, "status": "on"}
    except Exception as e:
        print(f"Scan error: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

def ensure_network_manager():
    """Ensure NetworkManager is running and responding"""
    try:
        # Check if NetworkManager is running
        nm_status = subprocess.run(
            ["systemctl", "is-active", "NetworkManager"],
            capture_output=True,
            text=True
        )
        
        if nm_status.stdout.strip() != "active":
            print("NetworkManager is not running, attempting to start...")
            subprocess.run(["sudo", "systemctl", "start", "NetworkManager"], check=True)
            time.sleep(2)  # Give it time to start
            
        # Verify NetworkManager is responding
        test_cmd = subprocess.run(
            ["nmcli", "general", "status"],
            capture_output=True,
            text=True
        )
        
        if test_cmd.returncode != 0:
            print("NetworkManager not responding, attempting to restart...")
            subprocess.run(["sudo", "systemctl", "restart", "NetworkManager"], check=True)
            time.sleep(3)  # Give it time to restart
            
        return True
    except Exception as e:
        print(f"Failed to ensure NetworkManager is running: {e}")
        return False

@fastapi_app.get("/wifi/connection")
def current_wifi():
    try:
        # First ensure NetworkManager is running
        if not ensure_network_manager():
            return {"connected": False, "ssid": None, "signal": None, "error": "NetworkManager not available"}
        
        # Get current WiFi status
        wifi_state = wifi_status()
        if wifi_state["status"] != "on":
            return {"connected": False, "ssid": None, "signal": None, "status": wifi_state["status"]}
        
        # Get all active connections with detailed info
        connection_result = subprocess.run(
            ["nmcli", "-t", "-f", "TYPE,NAME,DEVICE,STATE", "connection", "show", "--active"],
            capture_output=True,
            text=True
        )
        
        if connection_result.returncode != 0:
            print("Error getting active connections:", connection_result.stderr)
            return {"connected": False, "ssid": None, "signal": None, "error": "Failed to get connections"}
        
        wifi_connection = None
        wifi_device = None
        connection_state = None
        
        # Find active WiFi connection
        for line in connection_result.stdout.strip().split('\n'):
            if line:
                try:
                    parts = line.strip().split(':')
                    if len(parts) >= 4:
                        conn_type, name, device, state = parts[:4]
                        if (conn_type == "802-11-wireless" or device.startswith('wl')) and state == "activated":
                            wifi_connection = name
                            wifi_device = device
                            connection_state = state
                            break
                except (ValueError, IndexError):
                    continue
        
        if not wifi_connection:
            # No active WiFi connection found
            # Check if WiFi is enabled but not connected
            device_status = subprocess.run(
                ["nmcli", "device", "status"],
                capture_output=True,
                text=True
            )
            
            if device_status.returncode == 0:
                for line in device_status.stdout.split('\n'):
                    if 'wifi' in line.lower():
                        status_parts = line.split()
                        if len(status_parts) >= 3:
                            status = status_parts[2].lower()
                            if status == "disconnected":
                                return {
                                    "connected": False,
                                    "ssid": None,
                                    "status": "disconnected",
                                    "device": status_parts[0]
                                }
            return {"connected": False, "ssid": None}
        
        # Get detailed info about the current connection
        detail_result = subprocess.run(
            ["nmcli", "-t", "-f", "SSID,SIGNAL,SECURITY", "device", "wifi", "list"],
            capture_output=True,
            text=True
        )
        
        if detail_result.returncode == 0:
            current_details = None
            for line in detail_result.stdout.strip().split('\n'):
                fields = line.strip().split(':')
                if len(fields) >= 3 and fields[0] == wifi_connection:
                    current_details = {
                        "connected": True,
                        "ssid": fields[0],
                        "security": fields[2] if len(fields) > 2 else "--",
                        "device": wifi_device,
                        "state": connection_state
                    }
                    break
            
            if current_details:
                return current_details
        
        # Fallback if we couldn't get detailed info
        return {
            "connected": True,
            "ssid": wifi_connection,
            "security": "--",
            "device": wifi_device,
            "state": connection_state
        }
    except Exception as e:
        print(f"Error getting WiFi connection: {str(e)}")
        return {
            "connected": False,
            "ssid": None,
            "error": str(e)
        }

@fastapi_app.get("/wifi/status")
def wifi_status():
    try:
        # First check if NetworkManager is running
        nm_status = subprocess.run(
            ["systemctl", "is-active", "NetworkManager"],
            capture_output=True,
            text=True
        )
        
        if nm_status.stdout.strip() != "active":
            print("NetworkManager is not running")
            try:
                # Try to start NetworkManager
                subprocess.run(["sudo", "systemctl", "start", "NetworkManager"], check=True)
                print("Started NetworkManager")
                # Give it a moment to initialize
                time.sleep(2)
            except Exception as nm_err:
                print(f"Failed to start NetworkManager: {nm_err}")
                return {"status": "error", "reason": "NetworkManager not running"}
                
        # Check if the wifi hardware is blocked
        rfkill = subprocess.run(
            ["rfkill", "list", "wifi"],
            capture_output=True,
            text=True
        )
        
        if "Soft blocked: yes" in rfkill.stdout:
            print("WiFi is soft blocked, attempting to unblock...")
            try:
                subprocess.run(["rfkill", "unblock", "wifi"], check=True)
                time.sleep(1)  # Give it a moment
            except Exception as unblock_err:
                print(f"Failed to unblock WiFi: {unblock_err}")
                return {"status": "off", "reason": "blocked"}
            
        # Then check nmcli status
        result = subprocess.run(
            ["nmcli", "radio", "wifi"],
            capture_output=True,
            text=True
        )
        
        if result.returncode == 0:
            status = result.stdout.strip().lower()
            if status != "enabled":
                print("WiFi radio is disabled, attempting to enable...")
                try:
                    subprocess.run(["nmcli", "radio", "wifi", "on"], check=True)
                    time.sleep(1)  # Give it a moment
                    return {"status": "on", "message": "WiFi radio enabled"}
                except Exception as radio_err:
                    print(f"Failed to enable WiFi radio: {radio_err}")
                    
            return {"status": "on" if status == "enabled" else "off"}
            
        # If nmcli command failed, check device status directly
        dev_status = subprocess.run(
            ["nmcli", "device", "status"],
            capture_output=True,
            text=True
        )
        
        if dev_status.returncode == 0:
            wifi_found = False
            for line in dev_status.stdout.split('\n'):
                if 'wifi' in line.lower():
                    wifi_found = True
                    if 'unavailable' in line.lower():
                        print("WiFi device is unavailable, checking hardware...")
                        # Try to bring up the WiFi interface
                        try:
                            interfaces = subprocess.run(
                                ["ip", "link", "show"],
                                capture_output=True,
                                text=True
                            )
                            for iface_line in interfaces.stdout.split('\n'):
                                if 'wlan' in iface_line.lower() or 'wifi' in iface_line.lower():
                                    iface_name = iface_line.split(':')[1].strip()
                                    subprocess.run(["sudo", "ip", "link", "set", iface_name, "up"], check=True)
                                    time.sleep(2)  # Give interface time to come up
                                    return {"status": "on", "message": f"Enabled interface {iface_name}"}
                        except Exception as iface_err:
                            print(f"Failed to bring up WiFi interface: {iface_err}")
                    else:
                        return {"status": "on"}
                        
            if not wifi_found:
                return {"status": "error", "reason": "No WiFi device found"}
                    
        return {"status": "off", "reason": "unavailable"}
        
    except Exception as e:
        print(f"Error checking WiFi status: {str(e)}")
        return {"status": "error", "reason": str(e)}

@fastapi_app.post("/wifi/toggle")
async def toggle_wifi(req: ToggleRequest):
    print(f"Received toggle request with state: {req.state}")
    
    if req.state not in ["on", "off"]:
        raise HTTPException(status_code=400, detail="Invalid state. Use 'on' or 'off'")
    
    try:
        if req.state == "off":
            # First, disconnect from any active WiFi connections
            try:
                current = current_wifi()
                if current.get("connected") and current.get("device"):
                    print(f"Disconnecting from current network on device {current['device']}")
                    subprocess.run(
                        ["sudo", "nmcli", "device", "disconnect", current["device"]],
                        capture_output=True,
                        text=True,
                        check=True
                    )
                    await asyncio.sleep(1)
            except Exception as e:
                print(f"Warning: Error during disconnect: {e}")

            # Disable WiFi in NetworkManager and prevent auto-connections
            print("Disabling NetworkManager WiFi and auto-connections...")
            try:
                # Disable WiFi radio
                subprocess.run(
                    ["sudo", "nmcli", "radio", "wifi", "off"],
                    capture_output=True,
                    text=True,
                    check=True
                )
                
                # Disable NetworkManager's WiFi auto-connect feature
                subprocess.run(
                    ["sudo", "nmcli", "general", "wifi", "off"],
                    capture_output=True,
                    text=True,
                    check=True
                )
            except Exception as e:
                print(f"Warning: Error configuring NetworkManager: {e}")

            # Finally, use rfkill to block WiFi at hardware level
            print("Blocking WiFi at hardware level...")
            subprocess.run(
                ["sudo", "rfkill", "block", "wifi"],
                capture_output=True,
                text=True,
                check=True
            )
        else:  # req.state == "on"
            # First unblock at hardware level
            print("Unblocking WiFi at hardware level...")
            subprocess.run(
                ["sudo", "rfkill", "unblock", "wifi"],
                capture_output=True,
                text=True,
                check=True
            )
            await asyncio.sleep(1)

            # Then enable in NetworkManager
            print("Enabling WiFi in NetworkManager...")
            subprocess.run(
                ["sudo", "nmcli", "radio", "wifi", "on"],
                capture_output=True,
                text=True,
                check=True
            )

            # Re-enable auto-connections if turning on
            subprocess.run(
                ["sudo", "nmcli", "general", "wifi", "on"],
                capture_output=True,
                text=True,
                check=True
            )

        print(f"WiFi {req.state} commands completed")
        
        # Wait for changes to take effect
        await asyncio.sleep(3)
        
        # Get the updated status
        status = wifi_status()
        current = None
        if status["status"] == "on":
            try:
                current = current_wifi()
            except Exception as e:
                print(f"Error getting current WiFi status: {e}")
        
        # Double-check if WiFi is really off when requested
        if req.state == "off" and status["status"] == "on":
            # Try one more time with more aggressive approach
            try:
                subprocess.run(["sudo", "rfkill", "block", "all"], check=True)
                subprocess.run(["sudo", "nmcli", "radio", "all", "off"], check=True)
                await asyncio.sleep(1)
                status = wifi_status()
            except Exception as e:
                print(f"Warning: Error during aggressive WiFi disable: {e}")

        # Notify all clients
        await sio.emit('wifi_state_change', {
            'status': status["status"],
            'current_network': current,
            'timestamp': time.time()
        })
        
        return {"status": status["status"]}
        
    except subprocess.CalledProcessError as e:
        error_msg = f"Failed to toggle WiFi: {str(e)}"
        print(error_msg)
        raise HTTPException(status_code=500, detail=error_msg)
    except Exception as e:
        error_msg = f"Unexpected error while toggling WiFi: {str(e)}"
        print(error_msg)
        raise HTTPException(status_code=500, detail=error_msg)

@fastapi_app.post("/wifi/connect")
async def connect_wifi(req: WifiConnectRequest):
    try:
        # Check if we're currently connected to a network
        current = current_wifi()
        if current["connected"]:
            # If we're already connected to the requested network, return early
            if current["ssid"] == req.ssid:
                return {"status": "connected", "connection": current}
            
            # Disconnect from current network first
            try:
                disconnect_result = subprocess.run(
                    ["nmcli", "device", "disconnect", current["device"]],
                    capture_output=True,
                    text=True,
                    check=True
                )
                # Wait for disconnection
                await asyncio.sleep(2)
            except subprocess.CalledProcessError as e:
                print(f"Warning: Failed to disconnect from current network: {str(e)}")

        # Force a rescan of available networks
        try:
            subprocess.run(["nmcli", "device", "wifi", "rescan"], check=True)
            await asyncio.sleep(1)  # Give time for the scan to complete
        except subprocess.CalledProcessError as e:
            print(f"Warning: Failed to rescan networks: {str(e)}")

        # Build the nmcli command based on whether a password is provided
        if req.password:
            cmd = ["nmcli", "device", "wifi", "connect", req.ssid, "password", req.password]
        else:
            cmd = ["nmcli", "device", "wifi", "connect", req.ssid]
            
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode != 0:
            raise HTTPException(status_code=400, detail=f"Failed to connect: {result.stderr}")
            
        # Wait for connection to establish
        await asyncio.sleep(3)
        
        # Get current connection status
        current = current_wifi()
        if current["connected"] and current["ssid"] == req.ssid:
            # Notify all clients about the new connection
            await sio.emit('wifi_state_change', {
                'status': "on",
                'current_network': current
            })
            return {"status": "connected", "connection": current}
        else:
            raise HTTPException(status_code=400, detail="Connection failed to establish")
            
    except subprocess.CalledProcessError as e:
        raise HTTPException(status_code=500, detail=f"Connection failed: {str(e)}")
        
@fastapi_app.post("/wifi/disconnect")
async def disconnect_wifi():
    try:
        # Get current connection first
        current = current_wifi()
        if not current["connected"]:
            return {"status": "not_connected"}
            
        # Store device info for reconnection
        device = current.get("device")
        
        # Try to notify clients before disconnecting
        try:
            await sio.emit('wifi_state_change', {
                'status': "disconnecting",
                'current_network': None
            })
        except Exception as notify_err:
            print(f"Warning: Could not notify clients before disconnect: {notify_err}")
            
        # Disconnect from WiFi
        result = subprocess.run(
            ["nmcli", "device", "disconnect", device] if device else ["nmcli", "connection", "down", current["ssid"]],
            capture_output=True,
            text=True,
            check=True
        )
        
        # Brief pause to let the disconnection take effect
        await asyncio.sleep(1)
        
        # Start monitoring connection status
        retry_count = 0
        max_retries = 3
        while retry_count < max_retries:
            try:
                # Check if actually disconnected
                current_check = current_wifi()
                if not current_check["connected"]:
                    return {"status": "disconnected"}
                    
                # If still connected, try again
                if retry_count < max_retries - 1:
                    print(f"Still connected after disconnect attempt {retry_count + 1}, retrying...")
                    subprocess.run(
                        ["nmcli", "device", "disconnect", device] if device else ["nmcli", "connection", "down", current["ssid"]],
                        capture_output=True,
                        text=True,
                        check=True
                    )
                    await asyncio.sleep(1)
                    
            except Exception as check_err:
                print(f"Error checking connection status: {check_err}")
                
            retry_count += 1
            
        raise HTTPException(
            status_code=500,
            detail="Failed to confirm disconnection after multiple attempts"
        )
            
    except subprocess.CalledProcessError as e:
        raise HTTPException(status_code=500, detail=f"Failed to disconnect: {str(e)}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Unexpected error during disconnect: {str(e)}")



# --------------------------
# Voice Chat
# --------------------------

from process_manager import voice_chat_manager

@fastapi_app.post("/voice-chat/control")
async def control_voice_chat(request: VoiceChatRequest):
    if request.action == "start":
        result = voice_chat_manager.start()
        if result["status"] == "error":
            raise HTTPException(status_code=500, detail=result["message"])
        return result
    elif request.action == "stop":
        result = voice_chat_manager.stop()
        if result["status"] == "error":
            raise HTTPException(status_code=500, detail=result["message"])
        return result
    else:
        raise HTTPException(status_code=400, detail="Invalid action. Use 'start' or 'stop'")

@fastapi_app.get("/voice-chat/status")
async def voice_chat_status():
    return voice_chat_manager.status()

# --------------------------
# Socket.IO
# --------------------------

# Store connected clients
connected_clients = set()

# Background task to monitor WiFi status
async def monitor_wifi_status():
    previous_status = None
    previous_connection = None
    consecutive_errors = 0
    max_consecutive_errors = 3
    
    while True:
        try:
            # Always force a NetworkManager check
            ensure_network_manager()
            
            wifi_state = wifi_status()
            current = None
            
            # Always try to get current connection info, even if status appears off
            try:
                current = current_wifi()
            except Exception as conn_err:
                print(f"Error getting current connection: {conn_err}")
                
            # More comprehensive status change detection
            status_changed = (
                previous_status != wifi_state["status"] or
                previous_connection is None or current is None or
                (current is not None and previous_connection is not None and
                 (current.get("connected") != previous_connection.get("connected") or
                  current.get("ssid") != previous_connection.get("ssid") or
                  current.get("signal") != previous_connection.get("signal") or
                  current.get("error") != previous_connection.get("error")))
            )
            
            if status_changed or consecutive_errors >= max_consecutive_errors:
                print(f"WiFi status changed: {wifi_state['status']}, Connection: {current}")
                
                # Broadcast to all connected clients
                if len(connected_clients) > 0:
                    await sio.emit('wifi_state_change', {
                        'status': wifi_state["status"],
                        'current_network': current,
                        'timestamp': time.time()
                    })
                
                previous_status = wifi_state["status"]
                previous_connection = current
                consecutive_errors = 0  # Reset error counter on successful update
                
        except Exception as e:
            consecutive_errors += 1
            print(f"Error in WiFi monitor (attempt {consecutive_errors}): {e}")
            
            if consecutive_errors >= max_consecutive_errors:
                # After several errors, notify clients of the problem
                if len(connected_clients) > 0:
                    await sio.emit('wifi_state_change', {
                        'status': 'error',
                        'current_network': {
                            'connected': False,
                            'ssid': None,
                            'signal': None,
                            'error': f"System error: {str(e)}"
                        },
                        'timestamp': time.time()
                    })
                
                # Wait longer between retries after repeated errors
                await asyncio.sleep(5)
            
        # Adaptive sleep: shorter interval if there are clients connected
        await asyncio.sleep(1 if connected_clients else 3)

@sio.event
async def connect(sid, environ):
    print(f"Socket.IO client connected: {sid}")
    connected_clients.add(sid)
    try:
        # Ensure NetworkManager is running
        ensure_network_manager()
        
        # Get current WiFi status
        wifi_state = wifi_status()
        current = None
        
        # Always try to get current connection info
        try:
            current = current_wifi()
        except Exception as conn_err:
            print(f"Error getting initial connection state: {conn_err}")
            current = {
                'connected': False,
                'ssid': None,
                'signal': None,
                'error': str(conn_err)
            }
            
        # Send initial state to the new client
        await sio.emit('wifi_state_change', {
            'status': wifi_state["status"],
            'current_network': current,
            'timestamp': time.time()
        }, to=sid)
        
        print(f"Sent initial state to {sid}: {wifi_state['status']}, {current}")
        
    except Exception as e:
        print(f"Error sending initial states to {sid}: {e}")
        # Send error state to client
        await sio.emit('wifi_state_change', {
            'status': 'error',
            'current_network': {
                'connected': False,
                'ssid': None,
                'signal': None,
                'error': f"System error: {str(e)}"
            },
            'timestamp': time.time()
        }, to=sid)

@sio.event
async def disconnect(sid):
    print(f"Socket.IO client disconnected: {sid}")
    connected_clients.discard(sid)  # Remove from connected clients set

# Start WiFi monitor when app starts
@fastapi_app.on_event("startup")
async def startup_event():
    asyncio.create_task(monitor_wifi_status())
